{% extends "layout.html" %}

{% block head %}
<title>initsearh</title>
<link href="static/css/index.css" rel="stylesheet" type="text/css" />
<script src="static/node_modules/jquery/dist/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
<meta charset="utf-8">
{% endblock %}

<script type="text/javascript">
    var test;
    function onload() {
        test = document.getElementById('search');
    }
    function clickedAllData() {
        location.href = 'http://data.avert.ie/values/!http://rdfs.org/sioc/ns%23container_of///';
    }
</script>

{% block main %}
<div id="boxes">
    <div id="leftbox" style="background-color: aliceblue;">
        <form action="{% url 'gengraph' %}" method="POST">
            {% csrf_token %}
            <label for="patientid">Get Patient:</label>
            <input type="text" name="patientid" id="patientid">
            <button type="submit" class="btn btn-primary btn-sm">Go</button>
        </form>
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" rel="stylesheet" />
        <div class="table-responsive">
            <table id="classes" class="table table-striped table-hover">
                <thead>
                    <tr>
                        <th>Classes</th>
                    </tr>
                </thead>
                <tbody>
                    {% if classes %}
                    {% for class, tmp in classes.items %}
                    <tr>
                        <form action="/nodegraph" method="POST">
                            <td>
                                <button onclick="addNode('{{ class }}', '{{ class }}', '{{ class }}', 0)" type="button"
                                    class="classname" id="{{ class }}">
                                    {{ class }}</button>
                            </td>
                        </form>
                    </tr>
                    {% endfor %}
                    {% endif %}
                </tbody>
            </table>
            <table id="header-fixed" class="table table-striped table-hover"></table>
        </div>
    </div>

    <div id="middlebox" style="display: inline-block; background-color: azure;" class="dropzone">
        <svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"></svg>
    </div>

    <div id="rightbox" style="background-color:aliceblue;">
        <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <form action="/">
            <button type="submit" onclick="" style="float: right" class="btn"><i class="fa fa-home"></i>
                Home</button>
        </form>
        <h4>Outline of Query</h4>
        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" rel="stylesheet" />
        <div class="table-responsive">
            <table class="table table-striped table-hover">
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Sub Category</th>
                    </tr>
                </thead>
                <tbody id="querytable">
                    <tr>

                    </tr>
                </tbody>
            </table>
            <table id="header-fixed" class="table table-striped table-hover"></table>
        </div>
    </div>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        var classes = JSON.parse('{{ classesjson|safe }}');
        console.log(classes);
        var baseNodes = [
        ]

        var baseLinks = [
        ]

        var nodes = [...baseNodes]
        var links = [...baseLinks]

        function getNeighbors(node) {
            return baseLinks.reduce(function (neighbors, link) {
                if (link.target.id === node.id) {
                    neighbors.push(link.source.id)
                } else if (link.source.id === node.id) {
                    neighbors.push(link.target.id)
                }
                return neighbors
            },
                [node.id]
            )
        }

        function isNeighborLink(node, link) {
            return link.target.id === node.id || link.source.id === node.id
        }


        function getNodeColor(node, neighbors) {
            if (Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1) {
                return node.level === 1 ? 'blue' : 'green'
            }

            return node.level === 1 ? 'red' : 'gray'
        }


        function getLinkColor(node, link) {
            return isNeighborLink(node, link) ? 'green' : '#E5E5E5'
        }

        function getTextColor(node, neighbors) {
            return Array.isArray(neighbors) && neighbors.indexOf(node.id) > -1 ? 'green' : 'black'
        }

        var height = $("#middlebox").height();
        var width = $("#middlebox").width();

        var svg = d3.select('svg')
        svg.attr('width', width).attr('height', height)

        var linkElements,
            nodeElements,
            textElements

        // we use svg groups to logically group the elements together
        var linkGroup = svg.append('g').attr('class', 'links')
        var nodeGroup = svg.append('g').attr('class', 'nodes')
        var textGroup = svg.append('g').attr('class', 'texts')

        var query = {}

        // simulation setup with all forces
        var linkForce = d3
            .forceLink()
            .id(function (link) { return link.id })
            .strength(function (link) { return link.strength })
            .distance(100)

        var simulation = d3
            .forceSimulation()
            .force('link', linkForce)
            .force('charge', d3.forceManyBody().strength(-20))
            .force('center', d3.forceCenter(width / 2, height / 2))

        var dragDrop = d3.drag().on('start', function (node) {
            node.fx = node.x
            node.fy = node.y
        }).on('drag', function (node) {
            simulation.alphaTarget(0.7).restart()
            node.fx = d3.event.x
            node.fy = d3.event.y
        }).on('end', function (node) {
            if (!d3.event.active) {
                simulation.alphaTarget(0)
            }
            node.fx = null
            node.fy = null
        })

        // select node is called on every click
        // we either update the data according to the selection
        // or reset the data if the same node is clicked twice
        function selectNode(selectedNode) {
            console.log(selectedNode.id);
            if (selectedNode.id in classes) {
                var tmpclassname = selectedNode.id
                var tmpvals = classes[tmpclassname]
                var length = 10;
                if (tmpvals.length < 10) {
                    length = tmpvals.length;
                }
                for (var i = 0; i < length; i++) {
                    addNode(tmpvals[i], tmpclassname, tmpvals[i], 1);
                }
                resetData()
                updateSimulation()
            }

            var neighbors = getNeighbors(selectedNode)

            // we modify the styles to highlight selected nodes
            nodeElements.attr('fill', function (node) { return getNodeColor(node, neighbors) })
            textElements.attr('fill', function (node) { return getTextColor(node, neighbors) })
            linkElements.attr('stroke', function (link) { return getLinkColor(selectedNode, link) })
        }

        // this helper simple adds all nodes and links
        // that are missing, to recreate the initial state
        function resetData() {
            var nodeIds = nodes.map(function (node) { return node.id })

            baseNodes.forEach(function (node) {
                if (nodeIds.indexOf(node.id) === -1) {
                    nodes.push(node)
                }
            })

            links = baseLinks
        }

        // diffing and mutating the data
        function updateData(selectedNode) {
            var neighbors = getNeighbors(selectedNode)
            var newNodes = baseNodes.filter(function (node) {
                return neighbors.indexOf(node.id) > -1 || node.level === 1
            })

            var diff = {
                removed: nodes.filter(function (node) { return newNodes.indexOf(node) === -1 }),
                added: newNodes.filter(function (node) { return nodes.indexOf(node) === -1 })
            }

            diff.removed.forEach(function (node) { nodes.splice(nodes.indexOf(node), 1) })
            diff.added.forEach(function (node) { nodes.push(node) })

            links = baseLinks.filter(function (link) {
                return link.target.id === selectedNode.id || link.source.id === selectedNode.id
            })
        }

        function updateGraph() {
            // links
            linkElements = linkGroup.selectAll('line')
                .data(links, function (link) {
                    return link.target.id + link.source.id
                })

            linkElements.exit().remove()

            var linkEnter = linkElements
                .enter().append('line')
                .attr('stroke-width', 1)
                .attr('stroke', 'rgba(50, 50, 50, 0.2)')

            linkElements = linkEnter.merge(linkElements)

            // nodes
            nodeElements = nodeGroup.selectAll('circle')
                .data(nodes, function (node) { return node.id })

            nodeElements.exit().remove()

            var nodeEnter = nodeElements
                .enter()
                .append('circle')
                .attr('r', 10)
                .attr('fill', function (node) { return node.level === 1 ? 'red' : 'gray' })
                .call(dragDrop)
                // we link the selectNode method here
                // to update the graph on every click
                .on('click', selectNode)
                .on('dblclick', addToQuery)
                .on("mouseover", function (d) { tooltip.text(d.id); return tooltip.style("visibility", "visible"); })
                .on("mousemove", function () { return tooltip.style("top", (d3.event.pageY - 10) + "px").style("left", (d3.event.pageX + 10) + "px"); })
                .on("mouseout", function () { return tooltip.style("visibility", "hidden"); });

            nodeElements = nodeEnter.merge(nodeElements)

            // texts
            textElements = textGroup.selectAll('text')
                .data(nodes, function (node) { return node.id })

            textElements.exit().remove()

            var textEnter = textElements
                .enter()
                .append('text')
                .text(function (node) { return node.label })
                .attr('font-size', 15)
                .attr('dx', 15)
                .attr('dy', 4)

            textElements = textEnter.merge(textElements)
        }

        var tooltip = d3.select("body")
            .append("div")
            .style("position", "absolute")
            .style("z-index", "10")
            .style("visibility", "hidden")
            .style("background", "#c5edd0")

        function addToQuery(selectedNode) {
            var recordCategory = getNeighbors(selectedNode);
            var subCategory = selectedNode.id;
            loadTableData(recordCategory[1], subCategory)
        }

        function loadTableData(recordCategory, subCategory) {
            const table = document.getElementById("querytable");
            let row = table.insertRow();
            let cat = row.insertCell(0);
            cat.innerHTML = recordCategory;
            let subcat = row.insertCell(1);
            subcat.innerHTML = subCategory;
        }


        function updateSimulation() {
            updateGraph()

            var radius = 15;

            simulation.nodes(nodes).on('tick', () => {
                nodeElements
                    .attr('cx', function (d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
                    .attr("cy", function (d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });
                textElements
                    .attr('x', function (node) { return node.x })
                    .attr('y', function (node) { return node.y })
                linkElements
                    .attr('x1', function (link) { return link.source.x })
                    .attr('y1', function (link) { return link.source.y })
                    .attr('x2', function (link) { return link.target.x })
                    .attr('y2', function (link) { return link.target.y })
            })

            simulation.force('link').links(links)
            simulation.alphaTarget(0.7).restart()
        }

        function addNode(idval, targetval, labelval, levelval) {
            var groupnum = Object.keys(classes).indexOf(targetval);
            baseNodes.push({ id: idval, group: groupnum, label: labelval, level: levelval })
            if (levelval == 1) {
                baseLinks.push({ target: targetval, source: idval, strength: 0.7 })
            }
            resetData()
            updateSimulation()
        }

        // last but not least, we call updateSimulation
        // to trigger the initial render
        updateSimulation()
    </script>
    {% endblock %}